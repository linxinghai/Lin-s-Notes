# C++ 开发从入门到精通

选择一本合适的书

本书的特色

本书的内容

各章的内容版式



再看逻辑运算符

赠送资料

售后服务

本书的读者对象

本书实例目录



1 说真的，我们还要学习C++吗

1.1 C++概述



1.2 开发工具——Visual C++

1.2.1 先看Visual C++的基本特点

1.2.2 安装Visual C++

1.2.3 Visual C++集成开发环境介绍



1.3 使用Visual Studio 2010

安装Visual Studio 2010

1.4 第一个C++程序



1.5 技术解惑

1.5.1 初学者经常不知道自己该学什么

1.5.2 初学者需要知道的正确观念



2 C++的重要特质分析



2.1 什么是面向对象（object-oriented）

2.1.1 什么是OOP

2.1.2 面向对象编程



2.2 分析C++的程序结构

2.2.1 从一段代码看C++程序结构

2.2.2 看C++的文件组织



2.3 必须遵循的编码规范

2.3.1 养成良好的风格

2.3.2 必须使用的注释

2.3.3 代码也需要化妆



2.4 输入输出基础

2.4.1 标准输入与输出对象

2.4.2 一个使用IO库的程序



2.5 算法是程序的灵魂

2.5.1 算法的概念

2.5.2 流程图表示算法

2.5.3 计算机语言表示算法



2.6 技术解惑

2.6.1 C++是面向对象，C是面向过程，那么这个对象和过程是什么意思呢

2.6.2 面向对象和面向过程的区别

2.6.3 学好C++的建议



3 你不一定了解的基础语法



3.1 先看标识符

3.1.1 C++中的保留字

3.1.2 需要遵循的命名规则



3.2 最基本的数据类型

3.2.1 数字运算型

3.2.2 逻辑运算型

3.2.3 字符型和字符串



3.3 标准类型库基础

3.3.1 命名空间using声明

3.3.2 标准库的string类

3.3.3 vector类型简介

3.3.4 迭代器简介

3.3.5 bitset类型初步



3.4 技术解惑

3.4.1 C++的标识符长度应当符合“min-length &amp;&amp; max-information”原则

3.4.2 字符和字符串有什么区别

3.4.3 C++中string类字符串和C中char*/char[]型字符串的差别

3.4.4 C++字符串和C字符串的转换

3.4.5 C++字符串和字符串结束标志



4 你不一定了解的变量和常量



4.1 先来看变量

4.1.1 定义变量

4.1.2 声明变量



4.2 变量的作用域

4.2.1 作用域和生存期

4.2.2 作用域限定符

4.2.3 存储类型

4.2.4 C++变量初始化

4.2.5 C++变量命名规范



4.3 再来看常量

4.3.1 什么是常量

4.3.2 常量的分类

4.3.3 常量的应用



4.4 技术解惑

4.4.1 C++常量的命名需要遵循一定的规范吗

4.4.2 在C++程序中，用const定义常量还是用#define

4.4.3 const是个很重要的关键字，在使用时应该注意些什么呢

4.4.4 关于全局变量的初始化，C语言和C++有区别吗

4.4.5 C/C++变量在内存中的分布

4.4.6 静态变量的初始化顺序



5 你不一定了解的运算符

5.1 先看赋值运算符

5.2 再看算术运算符

5.3 再看比较运算符

5.4 再看逻辑运算符

5.5 单独看++/−−运算符

5.6 再看位运算符

5.7 再看求字节数运算符

5.8 再看条件运算符

5.9 再看逗号运算符



5.10 技术解惑

5.10.1 避免运算结果溢出的一个方案

5.10.2 运算符重载的权衡

5.10.3 运算符的优先级和结合性

5.10.4 运算符重载是对已有运算符赋予多重含义



6 说说表达式



6.1 何谓表达式

6.1.1 看天下几分——表达式的分类

6.1.2 看表达式的书写方式



6.2 说说类型转换

6.2.1 先看隐式转换

6.2.2 再看显式转换



6.3 技术解惑

6.3.1 C/C++ 表达式的限制

6.3.2 表达式的真正功能



7 流程控制语句



7.1 最简单的语句和语句块

7.1.1 最简单的语句

7.1.2 说说语句块

7.1.3 最后是语句的总结

7.2 最常见的顺序结构



7.3 选择结构

7.3.1 先看单分支结构语句

7.3.2 再看双分支结构语句

7.3.3 还要使用多分支结构语句



7.4 循环结构详解

7.4.1 for语句循环

7.4.2 while语句

7.4.3 说说do-while语句



7.5 跳转语句

7.5.1 何谓break语句

7.5.2 何谓continue语句

7.5.3 何谓goto语句



7.6 技术解惑

7.6.1 循环中断的问题

7.6.2 分析循环语句的效率

7.6.3 几种循环语句的比较

7.6.4 C++中，for循环该怎么读

7.6.5 一个C++循环结构嵌套的问题

7.6.6 break语句和continue语句的区别



8 学习C++的最大障碍——指针

8.1 说说指针的基本概念



8.2 定义指针的几种方式

8.2.1 先定义指针

8.2.2 再识别指针

8.3 指针的分类



8.4 指针初始化

8.4.1 第一步：指针地址初始化

8.4.2 第二步：变量地址初始化

8.4.3 第三步：new分配内存单元

8.4.4 第四步：malloc函数分配内存单元



8.5 指针运算

8.5.1 算数运算

8.5.2 关系运算

8.6 指针的指针



8.7 使用指针

8.7.1 指针赋值

8.7.2 *操作符

8.8 分析指针和引用的关系



8.9 特殊指针

8.9.1 先看void型指针

8.9.2 再看空指针



8.10 技术解惑

8.10.1 指针的命名规范

8.10.2 C++中指针和引用的区别

8.10.3 变量在语言中的实质

8.10.4 C++开发如何避免和解决野指针

8.10.5 常量指针常量和常量引用常量

8.10.6 指针常量和引用常量的对比

8.10.7 常量指针和常量引用的对比



9 复合类型



9.1 数组基础

9.1.1 先定义数组

9.1.2 再看高级数组

9.1.3 分析数组的完整性

9.1.4 看维数不全

9.1.5 看无维数



9.2 动态数组

9.2.1 在堆上分配空间的动态数组

9.2.2 在栈上分配空间的“假动态”数组



9.3 数组存储

9.3.1 列存储

9.3.2 行存储



9.4 字符数组

9.4.1 定义字符数组

9.4.2 字符数组和字符串指针变量



9.5 数组初始化

9.5.1 先看定义时的初始化

9.5.2 初始化赋值语句



9.6 指针和数组

9.6.1 指向数组的指针

9.6.2 指针数组



9.7 使用数组

9.7.1 索引方式

9.7.2 指针方式



9.8 枚举

9.8.1 枚举基础

9.8.2 使用枚举



9.9 结构体

9.9.1 指向结构的指针

9.9.2 使用结构体

9.10 联合



9.11 自定义类型

9.11.1 先看typedef的作用

9.11.2 再看typedef的使用



9.12 技术解惑

9.12.1 字符数组和字符串的区别

9.12.2 字符数组和字符串可以相互转换

9.12.3 静态数组的速度快于动态数组

9.12.4 Arrays与Vector的区别

9.12.5 一道关于数组的面试题

9.12.6 数组名不是指针

9.12.7 作为一个用户自定义的类型，其所占用的内存空间是多少呢



10 函数



10.1 C++函数基础

10.1.1 先看定义方式

10.1.2 函数分类

10.1.3 函数定义实例



10.2 函数的参数

10.2.1 何谓形参实参

10.2.2 使用数组做函数参数

10.3 返回值和返回语句



10.4 调用函数

10.4.1 单独调用

10.4.2 函数表达式

10.4.3 实参调用

10.4.4 参数传递

10.5 函数递归

10.6 指向函数的指针

10.7 将函数作为参数



10.8 变量的作用域和生存期

10.8.1 变量作用域

10.8.2 静态存储变量和动态存储变量

10.9 函数main()和命令行处理



10.10 技术解惑

10.10.1 用typedef来定义一个函数指针类型

10.10.2 const关键字在函数中的作用

10.10.3 C++函数的内存分配机制

10.10.4 主函数和子函数的关系

10.10.5 函数声明和函数定义的区别

10.10.6 使用全局变量的注意事项

10.10.7 使用寄存器变量的注意事项

10.10.8 自动变量的特点



11 输入和输出



11.1 iostream对象

11.1.1 标准的I/O接口

11.1.2 文件I/O

11.1.3 字符串I/O



11.2 输出

11.2.1 预定义类型输出

11.2.2 自定义类型输出



11.3 输入

11.3.1 预定义类型输入

11.3.2 自定义类型输入



11.4 输入/输出格式化

11.4.1 使用ios类成员函数

11.4.2 使用操纵函数



11.5 文件

11.5.1 打开和关闭

11.5.2 顺序读写

11.5.3 随机读写

11.5.4 二进制文件

11.5.5 检测EOF



11.6 技术解惑

11.6.1 输入/输出时数的进制问题

11.6.2 数据间隔

11.6.3 内存文件映射

11.6.4 get和put的值的差异

11.6.5 使用控制符控制输出格式



12 类和封装



12.1 类

12.1.1 先声明类

12.1.2 再看类的属性

12.1.3 再看类的方法

12.1.4 再看构造函数

12.1.5 再看析构函数

12.1.6 再看静态成员

12.1.7 友元

12.1.8 再看修饰符

12.1.9 指向类成员的指针

12.1.10 嵌套类

12.1.11 类文件的组织



12.2 对象

12.2.1 先定义对象

12.2.2 再使用对象

12.2.3 再看this指针



12.3 技术解惑

12.3.1 浅拷贝和深拷贝

12.3.2 构造函数的错误认识和正确认识

12.3.3 保护性析构函数的作用



13 命名空间和作用域

13.1 命名空间介绍

13.2 定义命名空间



13.3 使用命名空间

13.3.1 使用域限定符

13.3.2 使用using指令

13.3.3 using声明

13.3.4 别名



13.4 作用域

13.4.1 什么是作用域

13.4.2 作用域的分类



13.5 技术解惑

13.5.1 using指令与using声明的比较

13.5.2 为什么需要命名空间

13.5.3 命名空间的作用

13.5.4 在C++中使用这些头文件的方法



14 类的继承和派生

14.1 继承与派生的基本概念

14.2 C++继承机制



14.3 继承和派生的基本知识

14.3.1 单重继承、多重继承与继承链

14.3.2 公有派生和私有派生

14.3.3 保护成员与保护派生

14.3.4 友元类和友元函数



14.4 派生一个类

14.4.1 先看基类的使用状况

14.4.2 派生的使用状况

14.4.3 再看构造函数

14.4.4 再看析构函数

14.4.5 使用同名方法

14.4.6 使用同名属性



14.5 单重继承和多重继承

14.5.1 单重继承

14.5.2 多重继承

14.5.3 构造函数和析构函数

14.6 虚继承和虚基类



14.7 技术解惑

14.7.1 通过虚继承解决二义性问题

14.7.2 使用C++虚基类的注意事项

14.7.3 一个问题

14.7.4 多重继承的二义性

14.7.5 允许派生类中的成员名和基类中的成员名相同



15 多态性详解

15.1 基本概念

15.2 先看宏多态



15.3 虚函数

15.3.1 虚函数基础

15.3.2 静态绑定和动态绑定

15.3.3 纯虚函数



15.4 抽象类

15.4.1 什么是抽象类

15.4.2 抽象类的派生



15.5 运算符重载

15.5.1 运算符重载基础

15.5.2 重载一元运算符

15.5.3 重载二元运算符



15.6 函数重载

15.6.1 函数重载基础

15.6.2 参数类型不同的重载



15.7 流的重载

15.7.1 流插入重载

15.7.2 流提取重载



15.8 覆盖

15.8.1 覆盖函数

15.8.2 覆盖变量



15.9 技术解惑

15.9.1 重载、覆盖和隐藏的区别

15.9.2 在重载运算符的时候要权衡实施的必要性

15.9.3 为什么需要函数重载

15.9.4 重载函数的调用匹配

15.9.5 另一种虚方法查找方案

15.9.6 两种重载方法的比较



16 模板的威力

16.1 基本概念



16.2 类模板

16.2.1 定义类模板

16.2.2 使用类模板

16.2.3 类模板的派生

16.2.4 类模板和模板类的区别



16.3 函数模板

16.3.1 定义函数模板

16.3.2 函数模板示例

16.3.3 模板实例化

16.4 模板组合



16.5 技术解惑

16.5.1 在函数模板中使用多个类型参数时要避免类型参数的二义性

16.5.2 函数模板和模板函数的区别

16.5.3 函数模板和类模板的区别

16.5.4 仿函数的用处



17 进一步剖析string类

17.1 string类的方法



17.2 string类的运算

17.2.1 查找函数

17.2.2 替换函数

17.2.3 插入函数

17.2.4 删除函数

17.2.5 比较函数

17.2.6 连接函数

17.2.7 赋值函数

17.2.8 特性描述函数

17.2.9 构造函数

17.2.10 迭代器处理

17.2.11 其他几种处理函数



17.3 string类综合应用

17.3.1 头文件123.h

17.3.2 类实现文件yinyong.cpp

17.3.3 测试使用主文件zonghe.cpp



17.4 技术解惑

17.4.1 C++字符串和C字符串的转换

17.4.2 大小和容量函数

17.4.3 cstring类与string类的比较



18 异常处理

18.1 什么是异常处理



18.2 C++的异常处理机制

18.2.1 throw抛出异常

18.2.2 raise抛出异常

18.2.3 try-catch异常捕获

18.3 异常处理中的构造和析构

18.4 C++异常处理机制总结



18.5 技术解惑

18.5.1 编写软件的目标

18.5.2 关于C++的new关键字的异常处理

18.5.3 C语言异常处理和结构化异常处理有什么区别?

18.5.4 C++抛出异常不捕获，程序的空间会释放吗?

18.5.5 throw抛出异常的特点

18.5.6 关于C 异常处理的心得体会

18.5.7 慎用catch(...)

18.5.8 慎用继承体系里的类作为catch的参数

18.5.9 对象析构函数被调用的3种场合

18.5.10 不要在异常处理体系中寄希望于类型转换

18.5.11 有C++异常处理体系捕获不到的东西吗？

18.5.12 set_unexpected函数的用处

18.5.13 不要让异常逃离析构函数



19 内存管理

19.1 内存分类



19.2 栈内存管理

19.2.1 申请栈内存

19.2.2 使用栈内存

19.2.3 释放栈内存

19.2.4 改变内存大小



19.3 堆内存管理

19.3.1 申请堆内存

19.3.2 使用堆内存

19.3.3 释放堆内存

19.3.4 改变大小



19.4 技术解惑

19.4.1 堆和栈的区别

19.4.2 常见的内存错误及其对策

19.4.3 防止发生溢出错误



20 预处理

20.1 什么是预处理



20.2 C++中常见的预处理

20.2.1 文件包含

20.2.2 条件编译

20.2.3 布局控制

20.2.4 宏替换

20.2.5 其他预编译指令

20.3 分析宏的常见陷阱



20.4 技术解惑

20.4.1 预处理的未来

20.4.2 两者的意义

20.4.3 一个初学者的问题



21 错误和调试



21.1 什么是错误

21.1.1 Bug的由来

21.1.2 程序设计方面的解释

21.2 常见的错误分析

21.3 程序调试常见错误



21.4 C++编程中的调试技巧

21.4.1 调试标记

21.4.2 运行期间调试标记

21.4.3 把变量和表达式转换成字符串

21.4.4 C语言的assert()



21.5 技术解惑

21.5.1 编写规范易懂的代码

21.5.2 编写安全可靠的代码

21.5.3 Visual C++调试技术

21.5.4 常见的非语法错误



22 初入江湖——图书借阅系统的实现过程

22.1 项目要求

22.2 需求分析



22.3 系统具体实现

22.3.1 数据结构设计

22.3.2 系统主文件rent.cpp

22.3.3 菜单处理文件mainfunction.h

22.3.4 函数定义文件subfunction.h

22.3.5 菜单处理实现文件mainfunction.cpp

22.3.6 功能函数实现文件subfunction.cpp



23 开始闯关（1）——C++实现网络应用项目



23.1 项目要求

23.1.1 客户机/服务器模式介绍

23.1.2 客户机/服务器模式的运作流程



23.2 实现原理

23.2.1 什么是winsocket编程接口

23.2.2 winsocket中的函数



23.3 具体实现

23.3.1 客户端和服务器端的公用文件

23.3.2 实现服务器端

23.3.3 实现客户端



24 开始闯关（2）——C++实现游戏项目



24.1 计算机游戏基础

24.1.1 游戏的基本流程

24.1.2 游戏元素

24.1.3 游戏层次



24.2 项目分析

24.2.1 游戏的角色

24.2.2 游戏界面表现



24.3 具体实现

24.3.1 实现相关位图

24.3.2 变量与函数

24.3.3 实现全屏

24.3.4 类初始化

24.3.5 实现具体显示界面

24.3.6 信息提示

24.3.7 和时间段相关的操作

24.3.8 键盘操作

24.3.9 我方发射子弹

24.3.10 敌机出现

24.3.11 敌机发射子弹

24.3.12 敌机子弹移动

24.3.13 火力实现



25 功成名就——DirectX实现媒体播放器



25.1 DirectX技术基础

25.1.1 DirectX技术概述

25.1.2 DirectX的基本结构及组成

25.1.3 DirectX主要组件介绍



25.2 系统分析和设计

25.2.1 功能需求和效果展示

25.2.2 设计FilterGraph结构



25.3 实现媒体控制类

25.3.1 CDXGraph类初始化

25.3.2 创建Graph滤波器链表

25.3.3 设计图像窗口

25.3.4 媒体播放控制

25.3.5 视频全屏显示

25.3.6 抓图保存



25.4 实现播放器主题

25.4.1 打开一个媒体文件

25.4.2 渲染媒体文件

25.4.3 播放媒体文件

25.4.4 实现控制功能

25.4.5 实现拖放功能

25.4.6 实现音量调节功能

25.4.7 添加背景图片



26 笑傲江湖——C++网络视频监控系统

26.1 系统分析

26.2 系统设计

26.3 系统预览

26.4 数据库设计

26.5 选购监控卡



26.6 具体编程实现

26.6.1 设计公共模块

26.6.2 设计主窗体

26.7 设计管理员登录模块



26.8 设计监控管理模块

26.8.1 监控管理技术分析

26.8.2 编程监控管理

26.8.3 单元测试处理



26.9 设计广角自动监控模块

26.9.1 可行性分析

26.9.2 编程实现

26.9.3 单元测试

26.10 设计视频回放模块

26.11 分析绚丽界面的实现方法